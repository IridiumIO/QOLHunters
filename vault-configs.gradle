import groovy.json.JsonOutput
import groovy.json.JsonSlurper

def zipUrl = vault_pack_url
def zipFile = file("build/temp-vault-assets/archive.zip")
def outputDir = file("build/temp-vault-assets/unzipped")
def runDir = file("run")
def allowedNamespaces = ["minecraft:", "the_vault:"]

tasks.register('checkEmptyConfigDirs') {
    def runConfig = file("${runDir}/config")
    def runDefaults = file("${runDir}/defaultconfigs")

    runDir.mkdirs()

    if (runConfig.exists()) {
        throw new GradleException("run/config already exists, delete the directory to update")
    }

    if (runDefaults.exists()) {
        throw new GradleException("run/defaultconfigs already exists, delete the directory to update")
    }
}

tasks.register('downloadZip') {
    dependsOn 'checkEmptyConfigDirs'
    doLast {
        zipFile.parentFile.mkdirs()

        println "Downloading $zipUrl..."
        new URL(zipUrl).withInputStream { i -> zipFile.withOutputStream { it << i }
        }
    }
}

tasks.register('unzip') {
    dependsOn 'downloadZip'
    doLast {
        outputDir.mkdirs()

        copy {
            from zipTree(zipFile)
            into outputDir
        }
    }
}

tasks.register("removeModdedItemsFromConfig") {
    dependsOn 'unzip',
            'removeModdedItemsEnchantments',
            'removeModdedItemsPaxel',
            'removeModdedItemsAltar'
    doLast {
        println "Finished removing modded items from config."
    }
}

tasks.register("moveToRun") {
    dependsOn 'removeModdedItemsFromConfig'
    finalizedBy 'cleanupVaultAssets'
    doLast {
        def overridesConfig = file("${outputDir}/overrides/config")
        def overridesDefaults = file("${outputDir}/overrides/defaultconfigs")

        def runConfig = file("${runDir}/config")
        def runDefaults = file("${runDir}/defaultconfigs")

        runDir.mkdirs()

        if (!overridesConfig.exists()) {
            throw new GradleException("downloaded config doesn't exist")
        }
        if (!runConfig.exists()) {
            println "Moving config -> ${runConfig}"
            ant.move(file: overridesConfig, todir: runDir)
        } else {
            throw new GradleException("run/config already exists, delete the directory to update")
        }

        if (!overridesDefaults.exists()) {
            throw new GradleException("downloaded config doesn't exist")
        }
        if (!runDefaults.exists()) {
            println "Moving defaultconfigs -> ${runDefaults}"
            ant.move(file: overridesDefaults, todir: runDir)
        } else {
            throw new GradleException("run/defaultconfigs already exists, delete the directory to update")
        }
    }
}

tasks.register("cleanupVaultAssets") {
    doLast {
        def vaultAssetsDir = file("build/temp-vault-assets")
        if (vaultAssetsDir.exists()) {
            println "Deleting ${vaultAssetsDir}"
            delete vaultAssetsDir
        } else {
            println "No temp-vault-assets directory to delete."
        }
    }
}


tasks.register("getVaultConfigs") {
    group = "Vault Configs"
    dependsOn "moveToRun"
}

// Remove modded items from configs to remove error screens in dev env

def filterByAllowedNamespaces = inputMap -> {
    inputMap.findAll { key, value -> !(key.contains(":") && !allowedNamespaces.any { ns -> key.startsWith(ns) })
    }
}

tasks.register('removeModdedItemsEnchantments') {
    dependsOn 'unzip'
    doLast {
        def inputFile = file("${outputDir}/overrides/config/the_vault/gear_enchantment.json")
        def json = new JsonSlurper().parseText(inputFile.text)


        if (json.costs instanceof Map) {
            json.costs = filterByAllowedNamespaces(json.costs)
        } else {
            println "No 'costs' object found or it's not a map"
        }

        inputFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        println "Removed modded items from gear_enchantment.json"
    }
}

tasks.register('removeModdedItemsPaxel') {
    dependsOn 'unzip'
    doLast {
        def inputFile = file("${outputDir}/overrides/config/the_vault/paxel.json")
        def json = new JsonSlurper().parseText(inputFile.text)

        if (json.PULVERIZING_MAP instanceof Map) {
            def filteredMap = filterByAllowedNamespaces(json.PULVERIZING_MAP)
            filteredMap = filteredMap.findAll { key, value ->
                def outputItem = value?.item?.item
                if (outputItem instanceof String) {
                    allowedNamespaces.any { ns -> outputItem.startsWith(ns) }
                } else {
                    false
                }
            }

            json.PULVERIZING_MAP = filteredMap
        } else {
            println "No 'PULVERIZING_MAP' object found or it's not a map"
        }

        inputFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        println "Removed modded items from paxel.json"
    }
}

tasks.register('removeModdedItemsAltar') {
    dependsOn 'unzip'
    doLast {
        def inputFile = file("${outputDir}/overrides/config/the_vault/vault_altar/vault_altar_ingredients.json")
        def json = new JsonSlurper().parseText(inputFile.text)


        if (json.LEVELS instanceof Map) {
            json.LEVELS.each { levelKey, level ->
                level.each { categoryName, categoryList ->
                    if (categoryList instanceof List) {
                        categoryList.each { entry ->
                            def items = entry?.value?.items
                            if (items instanceof List) {
                                entry.value.items = items.findAll { itemEntry ->
                                    def itemName = itemEntry?.item
                                    itemName instanceof String && allowedNamespaces.any { ns -> itemName.startsWith(ns) }
                                }
                            }
                        }
                        level[categoryName] = categoryList.findAll { entry -> entry?.value?.items instanceof List && entry.value.items
                        }
                    }
                }
            }
        } else {
            println "LEVELS object not found or malformed"
        }


        inputFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
        println "Removed modded items from vault_altar_ingredients.json"
    }
}

tasks.register('updateVaultVersion') {
    group "Vault Configs"
    doLast {

        Object json
        try {
            def metadataUrl = "https://radimous.github.io/vh-version-metadata/latest.json"
            def jsonText = new URL(metadataUrl).text
            json = new JsonSlurper().parseText(jsonText)
        } catch (e) {
            throw new RuntimeException("Failed to download vault version metadata", e)
        }
        println json
        def vaultVersion = json.vault_hunters_version
        def packUrl = json.vault_pack_url
        // Validate required fields
        if (!vaultVersion) {
            throw new RuntimeException("Missing field: vault_hunters_version in JSON")
        }
        if (!packUrl) {
            throw new RuntimeException("Missing field: vault_pack_url in JSON")
        }
        File buildGradleFile = project.file("gradle.properties")
        if (!buildGradleFile.exists()) {
            throw new RuntimeException("gradle.properties not found at ${buildGradleFile.absolutePath}")
        }
        var contents = buildGradleFile.getText('UTF-8')

        contents = contents.replaceAll("vault_hunters_version=.*", "vault_hunters_version=${vaultVersion}")
        contents = contents.replaceAll("vault_pack_url=.*", "vault_pack_url=${packUrl}")
        buildGradleFile.write(contents, 'UTF-8')
    }
}
